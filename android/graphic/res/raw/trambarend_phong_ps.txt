precision mediump float;

// Vertex attributes form the mesh. Transformed by the vertex shader.
varying vec3 fcolor;
varying vec3 normalV;
varying vec3 eyedirV;
varying vec3 lightdirV;
varying vec2 uvV;
uniform sampler2D colorMap;
uniform sampler2D alphaMap;
uniform sampler2D normalMap;
uniform sampler2D specularMap;

uniform int hasLighting;

struct PhongMaterial
{
   vec4 emission;    // Ecm
   vec4 ambient;     // Acm
   vec4 diffuse;     // Dcm
   vec4 specular;    // Scm
   float shininess;  // Srm
};
uniform PhongMaterial material;

vec3 lightintensity = vec3(0.9, 0.9, 0.9);

// Simple implementation of the phong illumination model.
vec4 phong(vec3 n, vec3 v, vec3 s, vec3 l, vec3 ka, vec3 kd, vec3 ks, float ke) {

  if(dot(v,n) < 0.0) return vec4(0,0,0,0); // back-face

  // Normalization is good.
  n = normalize(n);
  //n = normalize(texture2D(normalMap, uvV).xyz*n);
  v = normalize(v);
  s = normalize(s);
  //s = normalize(texture2D(specularMap, uvV).xyz*s);

  // The ambient term.
  vec3 color = ka * l;

  float cosns = dot(n, s);
  if (cosns > 0.0) {
    // The diffuse term.
    color += kd * l * cosns;

    // The specular term.
    vec3 r = 2.0 * (cosns * n) - s;
    float cosrv = dot(r, v);
    if (cosrv > 0.0)
      color += ks * l * pow(cosrv, ke);
  }

  return vec4(color,1.0);
}

void main() {

  // color map
  vec3 texColor = texture2D(colorMap, uvV).rgb;

  // alpha map
  float c = texture2D(alphaMap, uvV).r;

  // mix day + cloud colors
  c = pow(c,0.35);
  vec4 finalColor = vec4((1.0-c)*texColor + c * vec3(1,1,1),1.0);
  finalColor = texture2D(alphaMap, uvV);

  gl_FragColor =  hasLighting == 2 ? finalColor * phong(normalV, eyedirV, lightdirV, lightintensity, material.ambient.rgb, material.diffuse.rgb, material.specular.rgb, material.shininess) : finalColor;
}
